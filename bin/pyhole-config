#!/usr/bin/env python3

# pyhole - a clone of the Pi-hole DNS adblocker, written in Python.
# pyhole  (c) 2016 by ryt51V
# Pi-Hole (c) 2015, 2016 by Jacob Salmela

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3 of the License.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Our very own module!
from pyhole import pyhole
# For running system commands and setting permissions.
import os
# For running commands and capturing stdout from them.
import subprocess
# For exitting.
import sys
# For named tuples
from collections import namedtuple
# For ncurses dialogs
# http://pythondialog.sourceforge.net/doc/Dialog_class_overview.html
# http://pythondialog.sourceforge.net/doc/widgets.html
from dialog import Dialog
# For managing apt packages
# https://apt.alioth.debian.org/python-apt-doc/library/apt.cache.html
# https://apt.alioth.debian.org/python-apt-doc/library/apt.package.html
import apt
# For looking up interfaces and IP addresses.
import netifaces
# For managing IP addresses
import ipaddress
# For file operations including ownership
import shutil

# Exit if not root.
pyhole.require_root()

########################
###     Variables    ###
########################

# Define the web server named tuple
w = namedtuple('webserver',
               'name, package_name, install_description'
              )

# Define the web server packages and their properties.
web_servers = [
    w('lighttpd', 'lighttpd', 'Install pyhole and pyhole-admin files and lighttpd hosts.'),
    w('apache'  , 'apache2' , 'Install pyhole and pyhole-admin files and apache vhosts.' ),
    w('Manual'  , None      , 'Install pyhole and pyhole-admin files only.'),
]

# Define the DNS servers named tuple

dp = namedtuple('dns_provider',
                          'name, servers'
                          )
                
# Define choices of DNS servers.

dns_providers = [
    dp('Google' , [ '8.8.8.8'       , '8.8.4.4'       ] ),
    dp('OpenDNS', [ '208.67.222.222', '208.67.220.220'] ),
    dp('Level3' , [ '4.2.2.1'       , '4.2.2.2'       ] ),
    dp('Norton' , [ '199.85.126.10' , '199.85.127.10' ] ),
    dp('Comodo' , [ '8.26.56.26'    , '8.20.247.20'   ] ),
    dp('Cloudflare' , [ '1.1.1.1'    , '1.0.0.1'   ] )
]

########################
###   Configuration  ###
########################

# Create a dialog object we will use for all ncurses dialogs.
d = Dialog(autowidgetsize = True)
d.set_background_title("pyhole-config")

# Initialise our apt cache so we can check if packages are installed.
apt_cache = apt.Cache()

########################
##  Helper Functions  ##
########################

def cancel_pressed():
    """Gracefully exit the script.  To be run whenever a user chooses cancel."""
    print("Cancel button pressed.  Exiting...")
    sys.exit()
#end def cancel_pressed():

def check_cancel(button):
    """Checks to see if the button pressed was one that we will exit on - d.CANCEL or d.ESC."""
    if (button == d.CANCEL) or (button == d.ESC): cancel_pressed()
#end def check_cancel(button):

def okcancel(text : str):
    """Displays a message box plus a cancel button, and quits on cancel or ESC."""
    button = d.yesno(text, yes_label = "OK", no_label = "Cancel")
    check_cancel(button)
    return button
#end def okcancel(text : str):

def package_is_installed(package : str):
    """Return whether a package is installed."""
    if package in apt_cache:
        # Package is in the cache - not neccesarily installed
        return apt_cache[package].is_installed
    else:
        # Package is not in the cache - can't be installed.
        return False
    #end else
#end def package_is_installed(package):

def package_install(package : str):
    """Install a package"""
    if not package in apt_cache:
        print("Package {0} is not in the apt cache.".format(package) )
        raise
    #end if not package in apt_cache:
    
    if apt_cache[package].is_installed:
        print("Package {0} is already installed.".format(package) )
        raise
    #end if apt_cache[package].is_installed:
    
    apt_cache[package].mark_install()
    apt_cache.commit()
    
    # Reload the changes to apt-cache
    apt_cache.open()
    
#end def package_install(package : str):

def copy_and_replace(src, dst, replacements):
    
    # Replacements must be a dict like, for example:
    # replacements = {
        # '@DNSSERVERS@' : DNSSERVERS,
        # '@INT@'        : interface
    # }
    
    with open(src) as infile, open (dst, 'w') as outfile:
        for line in infile:
            for src, target in replacements.items():
                line = line.replace(src, target)
            #end for src, target in replacements.items():
            outfile.write(line)
        #end for line in infile:
    #end with
#end def copy_and_replace(src, dst, replacements):

def is_raspbian():
    """Return True if running on Raspbian, false otherwise."""
    try:
        # Get the distro - e.g. Raspbian, Debian
        distro = subprocess.check_output( ['lsb_release',  '-si'] ).decode('utf-8').strip()
        if distro == "Raspbian":
            return True
        else:
            return False
        #end else:
    except:
        return False
    #end except:
    
#end def check_raspbian():

########################
##  Gather Functions  ##
########################

def show_welcome_message():
    """Display any welcome messages."""
    message = "This program will configure your pyhole.\n\nYou can choose cancel at any time during config and no changes will have been made to your system."
    okcancel(message)
#end def show_welcome_message:

########################
### Web Server

def choose_web_server():
    """Allow the user to choose the web server they want."""
    
    # Find out which of our choices are available.
    choices = []
    web_servers_installed = []
    
    for ws in web_servers:
        # The item for the "choice" list that we will pass to the menu dialog.
        choice = ( ws.name, ws.install_description )
        
        if ws.name == "Manual":
            # Manual is always an option.
            choices.append(choice)
        elif package_is_installed(ws.package_name):
            # Web servers are only an option if their package is installed.
            choices.append(choice)
            web_servers_installed.append(ws.package_name)
        #end if package_is_installed(ws['package_name']):
    #end for ws in web_servers:
    
    web_server_msgbox = "pyhole requires a web server with two virtual hosts - one to serve an empty page that replaces ads, and one for the admin web interface to view stats and whitelist or blacklist ad servers.\n\n"
    
    web_server_msgbox += "pyhole can automatically configure certain web servers for you if they are already installed.  Alternatively, pyhole can just install the web server files for you to use with a web server you configure manually yourself.\n\nThe web servers supported for automatic configuration are as follows:\n\n"
    
    # Display one web server on each line, except Manual of course.
    for ws in web_servers:
        if ws.name != 'Manual': web_server_msgbox += "{0}\n".format(ws.package_name)
    #end for w in web_servers:
    
    okcancel(web_server_msgbox)
    
    if len(web_servers_installed) == 0:
        web_server_message = "No web servers supported for automatic configuration appear to be installed.  If you wish for pyhole to configure one for you then please cancel pyhole-config and install one of the supported web servers above.  Otherwise you may proceed with manual configuration.\n\nIf you are unsure, cancel this config and run the following before continuing:\n\nsudo apt-get install lighttpd"
    else:
        web_server_message = "Web servers supported for automatic configuration that are already installed web servers appear below.  Please choose an option.\n\nIf you are unsure, choose {0}.".format(choices[0][0])
    #end else:
    
    button, answer = d.menu(web_server_message, choices=choices)
    
    check_cancel(button)
    
    return answer
    
#end def choose_web_server():

def choose_web_roots():
    """Allow the user to choose web roots."""
    web_root_message = "Choose where you would like pyhole to install the virtual hosts.\n\nIf you are unsure, leave these as the default."
    
    elements = [
        ("pyhole"      , 2, 2, "/var/www/pyhole"      , 2, 20, 50, 255),
        ("pyhole-admin", 4, 2, "/var/www/pyhole-admin", 4, 20, 50, 255)
    ]
    
    button, answer = d.form(web_root_message, elements = elements, form_height = 5)
    
    check_cancel(button)
    
    return answer
    
#end def chooce_web_roots():

def choose_webserver_password():
    """Allow the user to choose a password for the web interface"""
    
    base_message1 = """When accessing the pyhole admin interface, you will need to log on with the username 'pyhole' and a password of your choosing.  \n\nPlease enter a password to secure your pyhole web interface."""
    
    message1 = base_message1
    
    message2 = """Please re-enter your password to confirm"""
    
    password_validated = False
    
    while password_validated == False:
        button, answer1 = d.passwordbox(message1)
        check_cancel(button)
        
        button, answer2 = d.passwordbox(message2)
        check_cancel(button)
        
        error_message1 = ""
        
        if answer1 != answer2:
            error_message1 = """Passwords did not match.\n"""
        elif answer1 == "":
            error_message1 = """You cannot have an empty password.\n\nWe're not performing any other password validation here - make it something simple if you want, just not blank!\n"""
        else:
            password_validated = True
        #end else
        
        message1 = error_message1 + "\n" + base_message1
        
    #end while password_validated == False:
    
    return answer1
#end def choose_webserver_password():

def choose_disable_default_website(web_server):
    """Ask the user if they are running multiple web servers."""
    
    # 443 is a lie right now, but we don't want another service using it
    message = "pyhole's {0} web server requires ports 80 and 443.  If you are running another web server using one or both of these ports then you will need to disable that web server, change its ports, or ensure it is running on a different IP address to pyhole.  (You can choose pyhole's IP address later in this config.)\n\n".format(web_server)
    
    message += "Pyhole will not conflict with web servers that use ports other than 80 or 443, for example webmin which uses port 10000 by default.\n\n"
    
    message += "In particular, we need to override the default {0} website that runs on ports 80 and 443.  If you are already using the default {0} website then we won't touch it, but you will need to manually resolve IP and port binding conflicts in {0}'s configuration files yourself.\n\n".format(web_server)
    
    message += "Are you running another web server on {0}'s default website?  If you are unsure, choose no.".format(web_server)
    
    choices = [
        ( "No"  , "Override the {0} default website.".format(web_server) ),
        ( "Yes" , "I will fix any port / IP binding conflicts myself." )
    ]
    
    button, answer = d.menu(message, choices=choices)
    
    check_cancel(button)
    
    if answer == "Yes":
        return False
    else:
        return True
    #end else:
#end def choose_disable_default_website(web_server):

########################
### Networking

def choose_interface():
    """Allow the user to choose their network interface."""
    interfaces = netifaces.interfaces()
    
    choices = []
    for i in interfaces:
        choice = ( i, "", False )
        if i != "lo":
            choices.append(choice)
        #end if i != "lo":
    #end for i in interfaces:
    
    message = "Please select a network interface.\n\nIf you are unsure, eth0 is almost always the best choice if you are using a wired connection."
    
    answer = None
    
    while not answer:
        button, answer = d.radiolist(message, choices=choices)
        
        check_cancel(button)
    #end while not answer:
    
    return answer
    
#end def choose_interface():

def choose_ipv4_ipv6():
    """Allow the user to choose IPv4 and/or IPv6."""
    # Our choice of protocols.
    choices = [
        ('IPv4', "", True ),
        ('IPv6', "", False)
    ]
    
    message = 'Please select at least one protocol.\n\nIf you are unsure, leave these as they are.'
    
    answer = None
    
    while not answer:
        button, answer = d.checklist(text = message, choices=choices)
        
        check_cancel(button)
    #end while not answer:
    
    return answer
    
#end def choose_ipv4_ipv6():

def choose_ipv4_address(interface: str):
    """Allow the user to choose their IPv4 address on the provided interface."""
    # Get the IPv4 addresses on the given interface
    # AF_INET represents IPv4
    addrs = netifaces.ifaddresses(interface)[netifaces.AF_INET]
    
    # Get all of our choices
    # We index them as we want to return the full addr object.
    choices = []
    i = 0
    for a in addrs:
        description = "addr {0[addr]}  netmask {0[netmask]}  broadcast {0[broadcast]}".format(a)
        # The first argument needs to be a string; it won't work with int.
        choices.append( ( str(i), description, False ) )
        i += 1
    #end for a in addr:
    
    message = "Please select an IPv4 address on interface {0}.\n\nIf you are unsure, choose the first one.".format(interface)
    
    answer = None
    while not answer:
        button, answer = d.radiolist(text = message, choices=choices)
        check_cancel(button)
    #end while not answer:
    
    # Get the object represented by the chosen list item.
    chosen = addrs[int(answer)]
    
    # Convert to an IPv4Interface object
    addr_mask = "{0[addr]}/{0[netmask]}".format(chosen)
    return ipaddress.IPv4Interface(addr_mask)
    
#end def choose_ipv4_address(interface: str):

def choose_ipv6_address(interface: str):
    """Allow the user to choose their IPv6 address on the provided interface."""
    # Get the IPv6 addresses on the given interface
    # AF_INET6 represents IPv6
    addrs = netifaces.ifaddresses(interface)[netifaces.AF_INET6]
    
    # Get all of our choices
    # We index them as we want to return the full addr object.
    choices = []
    i = 0
    for a in addrs:
        description = "addr {0[addr]}  netmask {0[netmask]}".format(a)
        # The first argument needs to be a string; it won't work with int.
        choices.append( ( str(i), description, False ) )
        i += 1
    #end for a in addr:
    
    message = "Please select an IPv6 address on interface {0}.\n\n".format(interface)
    
    message += "If you wish to use IPv6, we assume you know what you are doing - this should be a static address.  We won't perform any further checks or offer to reconfigure it for you."
    
    answer = None
    while not answer:
        button, answer = d.radiolist(text = message, choices=choices)
        check_cancel(button)
    #end while not answer:
    
    # Get the object represented by the chosen list item.
    chosen = addrs[int(answer)]
    
    # Strip any "%eth0" from the IPv6 address
    addr_stripped = chosen['addr'].split('%')[0]
    
    # IPv6Interface is a bit funny.  It doesn't seem to accept IP/netmask format,
    # only CIDR format, despite the documentation suggesting otherwise.
    # So we will convert netmask to CIDR first.
    cidr_suffix = ipaddress.ip_address(chosen['netmask'])._prefix_from_ip_string(chosen['netmask'])
    
    # Convert to an IPv6Interface object
    addr_mask = "{0}/{1}".format(addr_stripped,cidr_suffix)
    return ipaddress.IPv6Interface(addr_mask)
    
#def choose_ipv6_address():

def choose_ipv4_reconfigure(interface : str, ipv4_interface):
    """Choose whether to reconfigure the ipv4 address.  Return True for reconfigure, False to keep."""
    
    ipv4_address = str(ipv4_interface.ip)
    
    if is_raspbian():
        # If we are running on Raspbian we will offer to configure a static IPv4 address.
        
        message = ""
        
        message += "You have chosen: IPv4 address {0} on interface {1}.\n\n".format(ipv4_address, interface)
        
        message += "Again, pyhole must have a static IP address.  If you have already configured one then you should choose to keep these settings.  If you have not configured one, or if you are unsure, you should choose for pyhole-config to configure a static IPv4 address for you.\n\n"
        
        choices = [
            ( "Keep"  , "Keep my IPv4 address settings as is." ),
            ( "Configure", "Configure a static IPv4 address for me." )
        ]
        
        button, answer = d.menu(message, choices=choices)
        
        check_cancel(button)
        
        if answer == "Configure":
            return True
        else:
            return False
        #end else:
        
    else:
        # If we are not running Raspbian then we leave static IP configuration up to the user. 
        
        # This logic is perhaps over-the-top, but as it's already writen...
        # Determine if the IPv4 address is likely to be static so the user
        # can make more of an informed choice.
        
        # There does not seem to be a decent way to tell whether or not an IPv4 address is static.
        # We will look in the file /etc/network/interfaces for the phrases below and judge.
        #   'iface <interface name> inet static'
        #   'iface <interface name> inet dhcp'
        # Yes this could fail for many reasons including use of /etc/network/interfaces, so we won't
        # make hard decisions based on this.
        
        ipv4_address_type = 'unknown'
        
        static_search_string    = 'iface {0} inet static'.format(interface)
        dynamic_search_string   = 'iface {0} inet dhcp'.format(interface)
        
        with open('/etc/network/interfaces', 'r') as f:
            interfaces_file = f.read()
        #end with open('/etc/network/interfaces', 'r') as f:
        
        if static_search_string in interfaces_file:
            ipv4_address_type = 'static'
        elif dynamic_search_string in interfaces_file:
            ipv4_address_type = 'dynamic'
        #end elif dynamic_search_string in interfaces_file:
        
        message = ""
        
        message += "Again, pyhole requires a static IPv4 address.\n\n"
        
        if ipv4_address_type == 'static':
            message += "It looks like your IPv4 address {0} on interface {1} is already static, which is good.  (This may be incorrect though.)\n\n".format(ipv4_address, interface)
        elif ipv4_address_type == 'dynamic':
            message += "It looks like your IPv4 address {0} on interface {1} is dynamic.  (This may be incorrect though.)  You need to have a static IP.  Please chooce Cancel and reconfigure a static IPv4 address.\n\n".format(ipv4_address, interface)
        else:
            message += "We're unable to tell whether your address {0} on interface {1} is dynamic or static.  You need to have a static IP.  If you do not believe you have set one, please chooce Cancel and reconfigure a static IPv4 address.\n\n".format(ipv4_address, interface)
        #end else:
                
        button, answer = okcancel(message)
        
        return False
        
#end def choose_ipv4_reconfigure(interface : str, ipv4_interface):

def choose_ipv4_new_static(interface: str, ipv4_interface):
    """Allow the user to choose their desired static IPv4 settings."""
    gateway = netifaces.gateways()['default'][netifaces.AF_INET]
    
    elements = [
        ("address", 2, 2, str(ipv4_interface.ip)        , 2, 15, 25, 25),
        ("netmask", 4, 2, str(ipv4_interface.netmask)   , 4, 15, 25, 25),
        ("gateway", 6, 2, gateway[0]                    , 6, 15, 25, 25)
    ]
    
    base_message = "Please enter your desired static IPv4 settings.\n\n"
    
    base_message += "If you are unsure, you can leave them as is.  It is possible your router could still try to assign this IPv4 address to a device, which would cause a conflict, but in most cases the router is smart enough to not do that and the device is smart enough not to accept the IP.  If you are worried, set the address to one outside your DHCP pool and/or make a DHCP reservation for the IPv4 address you set here."
    
    message = base_message
    validated = False
    
    
    while validated == False:
        button, answer = d.form(message, elements = elements, form_height = 7)
        check_cancel(button)
        
        error_message = ""
        
        validated = True
        if not pyhole.valid_ip(answer[0]):
            validated = False
            error_message += "Address is not valid: {0}\n".format(answer[0])
        #end if not pyhole.valid_ip(answer[0]):
        
        if not pyhole.valid_ip(answer[1]):
            validated = False
            error_message += "Netmask is not valid: {0}\n".format(answer[1])
        #end if not pyhole.valid_ip(answer[1]):
        
        if not pyhole.valid_ip(answer[2]):
            validated = False
            error_message += "Gateway is not valid: {0}\n".format(answer[2])
        #end if not pyhole.valid_ip(answer[2]):
        
        message = error_message + "\n" + base_message
        
    #end while validated == False:
    
    # answer[0] address
    # answer[1] netmask
    # answer[2] gateway
    
    # Turn address and netmask into ipv4 interface object
    addr_mask = "{0}/{1}".format( answer[0], answer[1] )
    new_ipv4_interface = ipaddress.IPv4Interface(addr_mask)
    
    # Return ipv4 interface object and gateway
    return new_ipv4_interface, answer[2]
    
#end def choose_ipv4_new_static(interface: str, ipv4_interface):

def set_ipv4_static_raspbian(interface : str, ipv4_interface, gateway):
    
    cidr = ipv4_interface.with_prefixlen
    
    # Generate our dhcpcd.conf content.
    # Using the gateway as the DNS server is poor practice - it's not neccesarily a DNS server!
    # But it is what the original Pi-hole did and not sure of the best alterative.
    dhcpcd_content = """\
    interface {0}
    static ip_address={1}
    static routers={2}
    static domain_name_servers={3}
    """.format(interface, cidr, gateway, gateway)
    
    # Append the content to the existing dhcpcd file.
    with open('/etc/dhcpcd.conf', 'a') as f:
        f.write(dhcpcd_content)
    #end with
    
#end def set_ipv4_static_raspbian(interface : str, ipv4_interface, gateway):

########################
### DNS Servers

def choose_dns_custom_servers(quantity=2):
    """Allow the user to choose custom DNS servers."""
    elements = []
    
    for x in range( 0 , quantity ):
        # Rows are 2, 4, 6, 8, etc. to allow some nice spacing.
        row = 2*(x+1)
        row1_col1_msg = "Server {0} IP Address".format(x+1)
        
        elements.append( ( row1_col1_msg , row, 2  , "" , row , 25 , 20 , 20 ) )
        elements.append( ( "Port"        , row, 48 , "" , row , 54 , 7  , 5  ) )
    #end for x in range( 0 , quantity ):
    
    base_message = "Enter the details of your DNS provider.  You can enter up to {0} servers on this screen.\n\n".format(quantity)
    
    base_message += "Port is optional and should only be specified if the provider of your DNS server explicitly says to use it.  If you are unsure then leave the Port fields blank."
    
    # Form height is 2*number of rows + 1 to allow nice spacing.
    form_height = 2*quantity + 1
    
    message = base_message
    
    servers_validated = False
    
    while servers_validated == False:
        button, answer = d.form(message, elements = elements, form_height = form_height)
        
        check_cancel(button)
        
        servers = []
        servers_validated = True
        error_message = ""
        
        for x in range( 0 , quantity ):
            # Generate our dns_provider object from the answers
            # answer[2*x] is the IP address and answer[2*x+1] is the port.
            # e.g.
            #   x=0     IP: answer[0]   Port: answer[1]
            #   x=1     IP: answer[2]   Port: answer[3]
            #   x=2     IP: answer[4]   Port: answer[5]
            #   etc.
            # If the custom port is specified, add it after a # after the IP.
            # This is dnsmasq.conf syntax.
            
            ip   = answer[2*x]
            port = answer[2*x+1]
            
            
            # If a server was entered...
            if ip:
                
                # Check if the IP is valid.
                if not pyhole.valid_ip(ip): 
                    # If not, set servers_validated to false so we return back to the menu.
                    servers_validated = False
                    error_message += "Server {0} IP address is not valid: {1}\n".format( x+1, ip )
                #end if not pyhole.valid_ip(ip):
                
                if port:
                    # Similarly, check if the port is valid.
                    if not pyhole.valid_port(port): 
                        servers_validated = False
                        error_message += "Server {0} port is not valid: {1}\n".format( x+1, port )
                    #end if not pyhole.valid_port(port):
                    server = "{0}#{1}".format(ip, port)
                else:
                    server = ip
                #end else:
                
                # Add it to our list.
                servers.append(server)
            #end if answer[2*x]:
        #end for x in range( 0 , quantity ):
        
        # We must have at least one server!
        if len(servers) == 0:
            servers_validated = False
            error_message += "You must enter at least one server.\n"
        #end if len(servers) == 0:
        
        # The message we will display on next run of the menu.
        message = error_message + "\n" + base_message
        
        if servers_validated: dns_provider = dp("Custom", servers )
        
    #end while servers_validated = False:
    
    return dns_provider
    
#end def choose_dns_custom_servers(quantity=2):

def choose_dns_provider():
    """Allow the user to choose their DNS provider, or specify their own."""
    
    choices = []
    for dns in dns_providers:
        choice = ( dns.name, "" )
        choices.append(choice)
    #end for dns in dns_providers:
    
    custom = ( "Custom", "Set your own DNS servers." )
    choices.append(custom)
    
    message = "pyhole needs to use an upstream DNS provider to resolve normal (non-ad) domain names.  Please choose a DNS provider.\n\nIf you are unsure, choose Google DNS."
    
    button, answer = d.menu(message, choices=choices)
    
    check_cancel(button)
    
    if (answer == "Custom"):
        # If they have chosen custom, move on to asking them for their custom server.
        answer_provider = choose_dns_custom_servers(3)
    else:
        # If they have chosen a specific provider, look up the dns_provider object from their answer.
        for dns in dns_providers:
            if dns.name == answer:
                answer_provider = dns
                break
            else:
                answer_provider = None
            #end else:
        #end for dns in dns_providers:
    #end else:
    
    return answer_provider
    
# def choose_dns_provider():

########################
##  Config Functions  ##
########################

def install_dependencies(web_server):
    """pyhole's deb package specifies almost all of the dependencies required.  However a very small number are conditional dependencies, so we will install them here."""
    
    if web_server == 'apache':
        if not package_is_installed('libapache2-mod-php5'):
            package_install('libapache2-mod-php5')
        #end if
    #end if
    
#end def install_dependencies(web_server):

def write_pyhole_admin_php_conf():
    """Write variables to a php file for pyhole-admin to include."""
    php_conf_file = os.path.join(pyhole.config_dir, "pyhole-admin.php")
    
    # pyhole-admin will use protocolfactor to divide the number of entries in gravity_hosts by.
    # If IPv4 AND IPv6 are enabled then there will be two entries for each domain - so divide by 2
    # Otherwise there will be one entry for each domain - so divide by 1
    if use_ipv4 and use_ipv6:
        protocolfactor = 2
    else:
        protocolfactor = 1
    #end else:
    
    php_conf_content = """\
    <?php
        $protocolfactor = {0};\n
    ?>
    """.format(protocolfactor)
    
    with open (php_conf_file, 'wt') as f:
        f.write(php_conf_content)
    #end with
    
#end def write_pyhole_admin_php_conf():

def install_dnsmasq_config(dns_provider, interface : str):
    """Reads the template dnsmasq conf file, makes replacements, and outputs to the final location."""
    
    dnsmasq_conf_in  = os.path.join(pyhole.share_dir, 'conf/dnsmasq/01-pyhole.conf')
    dnsmasq_conf_out = '/etc/dnsmasq.d/01-pyhole.conf'
    
    # Generate all "server = x.x.x.x" lines
    DNSSERVERS = ""
    
    for s in dns_provider.servers:
        DNSSERVERS += "server={0}\n".format(s)
    #end for s in dns_provider.servers:
    
    # The strings we are replacing.
    replacements = {
        '@DNSSERVERS@' : DNSSERVERS,
        '@INT@'        : interface
    }
    
    copy_and_replace(dnsmasq_conf_in, dnsmasq_conf_out, replacements)
    
#end def install_dnsmasq_config(dns_provider, interface : str):

def create_pyhole_log_file():
    pyhole_log_file = '/var/log/pyhole.log'
    
    # Create an empty file
    open(pyhole_log_file, 'a').close()
    # Set owner to dnsmasq and group owner to pyhole, the former with write access.
    shutil.chown(pyhole_log_file, user = 'dnsmasq', group = 'pyhole')
    os.chmod(pyhole_log_file, mode = 0o644 )
    
    # Note that when logrotate is run, pyhole.logrotate specifies to create the new file
    # with the above mode and owner.
    # So if the above needs to be changed, so will pyhole.logrotate.
    
#end def create_dnsmasqd_log_file():

def create_htpasswd_file(password):
    htpasswd_file  = os.path.join(pyhole.config_dir, 'htpasswd')
    htpasswd_cmd = 'htpasswd -cb "{0}" pyhole "{1}"'.format(htpasswd_file, password)
    os.system( htpasswd_cmd )
    
    return htpasswd_file
#end def create_htpasswd_file(password):

def install_webserver_config(web_server, interface : str, ipv4_interface, web_root_pyhole, web_root_admin, htpasswd_file):
    """Generate and install web server configs, and enable / disable required sites and modules."""
    
    # The strings we are replacing.
    replacements = {
        '@IPv4addr@'        : str(ipv4_interface.ip),
        '@INT@'             : interface,
        '@web_root_pyhole@' : web_root_pyhole,
        '@web_root_admin@'  : web_root_admin,
        '@htpasswd_file@'   : htpasswd_file
    }
    
    if web_server == "lighttpd":
        # Copy the one "virtual host" file 01-pyhole.conf for both pyhole and pyhole-admin websites.
        lighttpd_pyhole_in = os.path.join(pyhole.share_dir, 'conf/lighttpd/01-pyhole.conf')
        lighttpd_pyhole_out = '/etc/lighttpd/conf-available/01-pyhole.conf'
        
        copy_and_replace(lighttpd_pyhole_in, lighttpd_pyhole_out, replacements)
        
        # Enable modules and the websites
        os.system("lighty-enable-mod fastcgi fastcgi-php")
        os.system("lighty-enable-mod pyhole")
        
        # "Disable" the default lighttpd website if this was set
        # We do this this just by copying a custom config that is essentially
        # the default lighttpd.conf but with port 81 instead of 80.
        if disable_default_website:
            lighttpd_conf_in = os.path.join(pyhole.share_dir, 'conf/lighttpd/lighttpd.conf')
            lighttpd_conf_out = '/etc/lighttpd/lighttpd.conf'
            
            # Backup the original file.
            lighttpd_conf_out_bak = lighttpd_conf_out + ".orig"
            shutil.move(lighttpd_conf_out, lighttpd_conf_out_bak)
            
            copy_and_replace(lighttpd_conf_in, lighttpd_conf_out, replacements)
        #end if disable_default_website:
        
    elif web_server == "apache":
        # Copy the two "virtual host" files; pyhole.conf and pyhole-admin.conf
        
        apache_pyhole_in = os.path.join(pyhole.share_dir, 'conf/apache/pyhole.conf')
        apache_pyhole_out = '/etc/apache2/sites-available/pyhole.conf'
        
        copy_and_replace(apache_pyhole_in, apache_pyhole_out, replacements)
        
        apache_admin_in = os.path.join(pyhole.share_dir, 'conf/apache/pyhole-admin.conf')
        apache_admin_out = '/etc/apache2/sites-available/pyhole-admin.conf'
        
        copy_and_replace(apache_admin_in, apache_admin_out, replacements)
        
        # Enable modules and the websites
        os.system("a2enmod headers rewrite")
        os.system("a2ensite pyhole")
        os.system("a2ensite pyhole-admin")
        
        # Disable the default apache website if this was set.
        if disable_default_website:
            os.system("a2dissite 000-default")
        #end if disable_default_website:
    elif web_server == "Manual":
        pass
    #end elif
    
#end def install_webserver_config(web_server):

def install_webserver_files(web_root_pyhole, web_root_admin):
    pyhole_in  = os.path.join(pyhole.share_dir, 'www/pyhole/pyhole'     )
    pyhole_out = os.path.join(web_root_pyhole , 'pyhole'                )
    admin_in   = os.path.join(pyhole.share_dir, 'www/pyhole-admin/admin')
    admin_out  = os.path.join(web_root_admin  , 'admin'                 )
    
    # copytree requires the destination does not exist.
    # So we try to delete our destinations first.
    
    try: shutil.rmtree(pyhole_out)
    except: pass
    
    try: shutil.rmtree(admin_out)
    except: pass
    
    # Copy folder contents to new folder.
    shutil.copytree(pyhole_in, pyhole_out)
    shutil.copytree(admin_in , admin_out )
    
#end def install_webserver_files(web_root_pyhole, web_root_admin):

def set_sudoers_file_permissions():
    # Sudoers file is automatically installed by the deb package.
    # Just need to set permissions.
    sudoers_file_out = '/etc/sudoers.d/pyhole'
    
    os.chmod(sudoers_file_out, mode = 0o440 )
#end def set_sudoers_file_permissions():

def create_pyhole_user():
    # We are OK to just go ahead and run useradd even if the user already exists.
    # A message will display but this is not a problem.
    # For reference, the exit code is 9 when the user already exists.
    os.system("useradd --system --shell /usr/sbin/nologon pyhole")
#end def create_pyhole_user:

def set_dir_permissions():
    # /var/lib/pyhole needs to have group owner pyhole
    # and be group writeable.
    shutil.chown(pyhole.var_dir, user = 'root', group = 'pyhole')
    os.chmod(pyhole.var_dir, mode = 0o775 )
    
    # That's it.
    # /etc/pyhole should root writeable like anything else in /etc.
    # Ditto with /usr/share/pyhole.
#end def set_dir_permissions():

########################
###   Gather Info    ###
########################

# Gather information from the user, but don't make any changes.

# Welcome!
show_welcome_message()

########################
### Web Server

# Choose a web server and web root paths.
web_server = choose_web_server()


if web_server == 'Manual':
    manual_message = "You have chosen for pyhole to install to a manually configured web server.  Please keep in mind this means you need to perform all web server configuration yourself, including:\n\n"
    
    manual_message += "- Configuring your web server to use the correct ports and IP address for pyhole.\n"
    manual_message += "- Ensuring the website is protected from unauthorised access, for example with a username or password.\n"
    okcancel(manual_message)
    
    web_root_pyhole, web_root_admin = choose_web_roots()
    
    web_password_set = False
    disable_default_website = False
else:
    web_root_pyhole, web_root_admin = choose_web_roots()
    
    web_password = choose_webserver_password()
    web_password_set = True
    
    disable_default_website = choose_disable_default_website(web_server)
#end else:

########################
### IP addresses

ip_message = """As pyhole will be running a DNS server, it is essential that its internal IP address is static.  A dynamic internal IP is not suitable.  (A DHCP reservation may work in some situations but is not recommended.)

If you are running pyhole on Raspbian (e.g. on a Raspberry Pi) and have not yet modified /etc/dhcpcd.conf or /etc/network/interfaces, pyhole can set a static IPv4 address for you (though if you know how to set one manually it is recommended you configure this outside of pyhole).

In all other cases, if you have not already configured a static IPv4 address you should choose Cancel now and configure one now before rerunning pyhole-config.  Similarly, if you wish to use IPv6, if you have not already configured a static IPv6 address then you should Cancel now and configure one first.

Furthermore, if you are already running another web server, you MUST allocate a SECOND static IP address for pyhole.  If you have configured multiple IP addresses then you will be able to choose which one you use for pyhole.

(Note that all of the above refers to your server's INTERNAL IP(s).  Your external IP does not matter - it can be static, dynamic, whatever.)
"""

okcancel(ip_message)

# Choose an interface, whether using IPv4 and/or IPv6, and addresses.
interface = choose_interface()

protocols = choose_ipv4_ipv6()

use_ipv4 = 'IPv4' in protocols
use_ipv6 = 'IPv6' in protocols

if use_ipv4:
    ipv4_interface = choose_ipv4_address(interface)
    ipv4_reconfigure = choose_ipv4_reconfigure(interface, ipv4_interface)
    
    if ipv4_reconfigure:
        new_ipv4_interface, gateway = choose_ipv4_new_static(interface, ipv4_interface)
        ipv4_interface = new_ipv4_interface
    #end if ipv4_reconfigure:
#end if use_ipv4:

if use_ipv6:
    ipv6_interface = choose_ipv6_address(interface)
#end if use_ipv6:

########################
### DNS Servers

# Choose upstream DNS servers
dns_provider = choose_dns_provider()

# Above this line, no changes have been made to the system.
okcancel("pyhole is now ready to be configured from your answers to the previous questions.  No permanent changes have been made to your system yet.\n\nShall we proceed?")

########################
###     Configure    ###
########################

# Start configuring!

########################
### Conf files

# Write pyhole conf file.

pyhole.config['DEFAULT']                        = {}
pyhole.config['DEFAULT']['pyhole_configured']   = "True"

pyhole.config['Network']                        = {}
pyhole.config['Network']['interface']           = interface
pyhole.config['Network']['use_ipv4']            = str(use_ipv4)
pyhole.config['Network']['use_ipv6']            = str(use_ipv6)
if use_ipv4:
    pyhole.config['Network']['ipv4_addr']   = str(ipv4_interface.ip)
    pyhole.ipv4_addr                        = str(ipv4_interface.ip)
#end if
if use_ipv6:
    pyhole.config['Network']['ipv6_addr']   = str(ipv6_interface.ip)
    pyhole.ipv6_addr                        = str(ipv6_interface.ip)
#end if

pyhole.config['WebServer']                      = {}
pyhole.config['WebServer']['web_server']        = web_server
pyhole.config['WebServer']['web_root_pyhole']   = web_root_pyhole
pyhole.config['WebServer']['web_root_admin']    = web_root_admin

# Write and then re-read the config file.
pyhole.write_config()
pyhole.read_config()

# Write pyhole-admin.php conf file
write_pyhole_admin_php_conf()

########################
### Main configuration

# Stop dnsmasq and the web server.
print("::: Stopping services...")
pyhole.services_changestate(web_server, stop = True)

# Standard dependencies are enumerated in the .deb package - this config
# shouldn't be running if they are not already installed.
# We check for and install conditional dependencies
# e.g. libapache2-mod-php5 if using apache
print("::: Installing any missing conditional dependencies...")
install_dependencies(web_server)

# Set static IP if required.
if ipv4_reconfigure:
    set_ipv4_static_raspbian(interface, ipv4_interface, gateway)
#end if

# Create pyhole user and set permissions.
print("::: Creating pyhole user...")
create_pyhole_user()
print("::: Setting folder permissions...")
set_dir_permissions()

# Create configs & set permissions.

print("::: Installing config files...")
install_dnsmasq_config(dns_provider, interface)
create_pyhole_log_file()
set_sudoers_file_permissions()
print("::: Setting admin interface password...")
htpasswd_file = create_htpasswd_file(web_password)

# Web server

print("::: Installing web server...")
install_webserver_config(web_server, interface, ipv4_interface, web_root_pyhole, web_root_admin, htpasswd_file)
install_webserver_files(web_root_pyhole, web_root_admin)

# Invoke pyhole-gravity
print("::: Invoking gravity...")
pyhole.pyhole_gravity()

# Start dnsmasq and the web server
print("::: Restarting services...")
pyhole.services_changestate(web_server, start = True)

########################
### Final Message

final_message = "Configuration complete!\n\nConfigure your devices to use the pyhole as their DNS server using:\n\n"

if use_ipv4:
    final_message += "IPv4 Address: "
    final_message += str(ipv4_interface.ip)
    final_message += "\n"
#end if

if use_ipv6:
    final_message += "IPv6 Address: "
    final_message += str(ipv6_interface.ip)
    final_message += "\n"
#end if

final_message += "\n"

if use_ipv4:
    final_message += "The pyhole admin interface can be accessed at:\n\n"
    final_message += "http://"
    final_message += str(ipv4_interface.ip)
    final_message += ":8080/admin/\n"
#end if

final_message += "\nIf you set a new IP address, you should reboot this server."

d.msgbox(final_message)
